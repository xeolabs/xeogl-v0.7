<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/controls/cameraControl.new.js - xeogl</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link href='https://fonts.googleapis.com/css?family=Exo+2:400,800,900,700,600,500|Roboto:100,300,400,500,700,900'  rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">

                <h1 class="projectTitle"><a href="../../">xeogl</a> / <a href="../../docs">API Docs</a></h1>

        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.7.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/AABBGeometry.html">AABBGeometry</a></li>
                                <li><a href="../classes/AABBHelper.html">AABBHelper</a></li>
                                <li><a href="../classes/AmbientLight.html">AmbientLight</a></li>
                                <li><a href="../classes/Annotation.html">Annotation</a></li>
                                <li><a href="../classes/AnnotationStory.html">AnnotationStory</a></li>
                                <li><a href="../classes/AxisHelper.html">AxisHelper</a></li>
                                <li><a href="../classes/BoxGeometry.html">BoxGeometry</a></li>
                                <li><a href="../classes/BuildableModel.html">BuildableModel</a></li>
                                <li><a href="../classes/Camera.html">Camera</a></li>
                                <li><a href="../classes/CameraControl.html">CameraControl</a></li>
                                <li><a href="../classes/CameraFlightAnimation.html">CameraFlightAnimation</a></li>
                                <li><a href="../classes/CameraFollowAnimation.html">CameraFollowAnimation</a></li>
                                <li><a href="../classes/CameraPath.html">CameraPath</a></li>
                                <li><a href="../classes/CameraPathAnimation.html">CameraPathAnimation</a></li>
                                <li><a href="../classes/Canvas.html">Canvas</a></li>
                                <li><a href="../classes/Clip.html">Clip</a></li>
                                <li><a href="../classes/ClipHelper.html">ClipHelper</a></li>
                                <li><a href="../classes/Clips.html">Clips</a></li>
                                <li><a href="../classes/Component.html">Component</a></li>
                                <li><a href="../classes/CubeTexture.html">CubeTexture</a></li>
                                <li><a href="../classes/CubicBezierCurve.html">CubicBezierCurve</a></li>
                                <li><a href="../classes/Curve.html">Curve</a></li>
                                <li><a href="../classes/CylinderGeometry.html">CylinderGeometry</a></li>
                                <li><a href="../classes/DirLight.html">DirLight</a></li>
                                <li><a href="../classes/EmphasisMaterial.html">EmphasisMaterial</a></li>
                                <li><a href="../classes/Entity.html">Entity</a></li>
                                <li><a href="../classes/Fresnel.html">Fresnel</a></li>
                                <li><a href="../classes/Frustum.html">Frustum</a></li>
                                <li><a href="../classes/Geometry.html">Geometry</a></li>
                                <li><a href="../classes/GeometryBuilder.html">GeometryBuilder</a></li>
                                <li><a href="../classes/GLTFModel.html">GLTFModel</a></li>
                                <li><a href="../classes/HeightmapGeometry.html">HeightmapGeometry</a></li>
                                <li><a href="../classes/Input.html">Input</a></li>
                                <li><a href="../classes/LabelHelper.html">LabelHelper</a></li>
                                <li><a href="../classes/LambertMaterial.html">LambertMaterial</a></li>
                                <li><a href="../classes/Lights.html">Lights</a></li>
                                <li><a href="../classes/LoadingEffect.html">LoadingEffect</a></li>
                                <li><a href="../classes/Lookat.html">Lookat</a></li>
                                <li><a href="../classes/Material.html">Material</a></li>
                                <li><a href="../classes/MetallicMaterial.html">MetallicMaterial</a></li>
                                <li><a href="../classes/Model.html">Model</a></li>
                                <li><a href="../classes/Nintendo3DSGeometry.html">Nintendo3DSGeometry</a></li>
                                <li><a href="../classes/OBBGeometry.html">OBBGeometry</a></li>
                                <li><a href="../classes/OBBHelper.html">OBBHelper</a></li>
                                <li><a href="../classes/OBJGeometry.html">OBJGeometry</a></li>
                                <li><a href="../classes/OBJModel.html">OBJModel</a></li>
                                <li><a href="../classes/Ortho.html">Ortho</a></li>
                                <li><a href="../classes/OutlineMaterial.html">OutlineMaterial</a></li>
                                <li><a href="../classes/Path.html">Path</a></li>
                                <li><a href="../classes/PathGeometry.html">PathGeometry</a></li>
                                <li><a href="../classes/Perspective.html">Perspective</a></li>
                                <li><a href="../classes/PhongMaterial.html">PhongMaterial</a></li>
                                <li><a href="../classes/Pin.html">Pin</a></li>
                                <li><a href="../classes/PlaneGeometry.html">PlaneGeometry</a></li>
                                <li><a href="../classes/PlaneHelper.html">PlaneHelper</a></li>
                                <li><a href="../classes/PointLight.html">PointLight</a></li>
                                <li><a href="../classes/QuadraticBezierCurve.html">QuadraticBezierCurve</a></li>
                                <li><a href="../classes/Quaternion.html">Quaternion</a></li>
                                <li><a href="../classes/Rotate.html">Rotate</a></li>
                                <li><a href="../classes/Scale.html">Scale</a></li>
                                <li><a href="../classes/Scene.html">Scene</a></li>
                                <li><a href="../classes/SceneJSModel.html">SceneJSModel</a></li>
                                <li><a href="../classes/Shadow.html">Shadow</a></li>
                                <li><a href="../classes/Skybox.html">Skybox</a></li>
                                <li><a href="../classes/SpecularMaterial.html">SpecularMaterial</a></li>
                                <li><a href="../classes/SphereGeometry.html">SphereGeometry</a></li>
                                <li><a href="../classes/Spinner.html">Spinner</a></li>
                                <li><a href="../classes/SplineCurve.html">SplineCurve</a></li>
                                <li><a href="../classes/SplineCurveHelper.html">SplineCurveHelper</a></li>
                                <li><a href="../classes/SpotLight.html">SpotLight</a></li>
                                <li><a href="../classes/StereoEffect.html">StereoEffect</a></li>
                                <li><a href="../classes/STLModel.html">STLModel</a></li>
                                <li><a href="../classes/Story.html">Story</a></li>
                                <li><a href="../classes/TeapotGeometry.html">TeapotGeometry</a></li>
                                <li><a href="../classes/TestModel.html">TestModel</a></li>
                                <li><a href="../classes/Texture.html">Texture</a></li>
                                <li><a href="../classes/TorusGeometry.html">TorusGeometry</a></li>
                                <li><a href="../classes/Transform.html">Transform</a></li>
                                <li><a href="../classes/Translate.html">Translate</a></li>
                                <li><a href="../classes/VectorTextGeometry.html">VectorTextGeometry</a></li>
                                <li><a href="../classes/Viewport.html">Viewport</a></li>
                                <li><a href="../classes/xeogl.html">xeogl</a></li>
                                <li><a href="../classes/xeogl.math.math.html">xeogl.math.math</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="..//modules/animation.html">animation</a></li>
                                <li><a href="..//modules/annotations.html">annotations</a></li>
                                <li><a href="..//modules/camera.html">camera</a></li>
                                <li><a href="..//modules/canvas.html">canvas</a></li>
                                <li><a href="..//modules/clipping.html">clipping</a></li>
                                <li><a href="..//modules/controls.html">controls</a></li>
                                <li><a href="..//modules/curves.html">curves</a></li>
                                <li><a href="..//modules/effects.html">effects</a></li>
                                <li><a href="..//modules/entities.html">entities</a></li>
                                <li><a href="..//modules/generation.html">generation</a></li>
                                <li><a href="..//modules/geometry.html">geometry</a></li>
                                <li><a href="..//modules/helpers.html">helpers</a></li>
                                <li><a href="..//modules/input.html">input</a></li>
                                <li><a href="..//modules/lighting.html">lighting</a></li>
                                <li><a href="..//modules/materials.html">materials</a></li>
                                <li><a href="..//modules/math.html">math</a></li>
                                <li><a href="..//modules/models.html">models</a></li>
                                <li><a href="..//modules/rendering.html">rendering</a></li>
                                <li><a href="..//modules/skyboxes.html">skyboxes</a></li>
                                <li><a href="..//modules/stories.html">stories</a></li>
                                <li><a href="..//modules/transforms.html">transforms</a></li>
                                <li><a href="..//modules/xeogl.html">xeogl</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <!--<div id="api-options">-->
                    <!--Show:-->
                    <!--<label for="api-show-inherited">-->
                        <!--<input type="checkbox" id="api-show-inherited" checked>-->
                        <!--Inherited-->
                    <!--</label>-->
            
                    <!--<label for="api-show-protected">-->
                        <!--<input type="checkbox" id="api-show-protected">-->
                        <!--Protected-->
                    <!--</label>-->
            
                    <!--<label for="api-show-private">-->
                        <!--<input type="checkbox" id="api-show-private">-->
                        <!--Private-->
                    <!--</label>-->
                    <!--<label for="api-show-deprecated">-->
                        <!--<input type="checkbox" id="api-show-deprecated">-->
                        <!--Deprecated-->
                    <!--</label>-->
            
                <!--</div>-->
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/controls/cameraControl.new.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * Rotates, pans and zooms the {{#crossLink &quot;Scene&quot;}}{{/crossLink}}&#x27;s {{#crossLink &quot;Camera&quot;}}{{/crossLink}} with keyboard, mouse and touch input.

 CameraControl fires these events:

 * &quot;hover&quot; - Hover enters a new object
 * &quot;hoverSurface&quot; - Hover continues over an object surface - fired continuously as mouse moves over an object
 * &quot;hoverLeave&quot;  - Hover has left the last object we were hovering over
 * &quot;hoverOff&quot; - Hover continues over empty space - fired continuously as mouse moves over nothing
 * &quot;picked&quot; - Clicked or tapped object
 * &quot;pickedSurface&quot; -  Clicked or tapped object, with event containing surface intersection details
 * &quot;doublePicked&quot; - Double-clicked or double-tapped object
 * &quot;doublePickedSurface&quot; - Double-clicked or double-tapped object, with event containing surface intersection details
 * &quot;pickedNothing&quot; - Clicked or tapped, but not on any objects
 * &quot;doublePickedNothing&quot; - Double-clicked or double-tapped, but not on any objects

 CameraControl only fires &quot;hover&quot; events when the mouse is up.

 For efficiency, CameraControl only does surface intersection picking when you subscribe to &quot;doublePicked&quot; and
 &quot;doublePickedSurface&quot; events. Therefore, only subscribe to those when you&#x27;re OK with the overhead incurred by the
 surface intersection tests.

 ## Panning

 ## Rotating

 ## Zooming

 ## Events

 ## Activating and deactivating

 ## Inertia

 ## First person

 ## Keyboard layout

 # Fly-to


 @class CameraControl
 @module xeogl
 @submodule controls
 @constructor
 @param [scene] {Scene} Parent {{#crossLink &quot;Scene&quot;}}{{/crossLink}}.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent scene, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this CameraControl.
 @param [cfg.firstPerson=false] {Boolean} Whether or not this CameraControl is in &quot;first person&quot; mode.
 @param [cfg.walking=false] {Boolean} Whether or not this CameraControl is in &quot;walking&quot; mode.
 @param [cfg.keyboardLayout=&quot;qwerty&quot;] {String} Keyboard layout.
 @param [cfg.doublePickFlyTo=true] {Boolean} Whether to fly the camera to each {{#crossLink &quot;Entity&quot;}}{{/crossLink}} that&#x27;s double-clicked.
 @param [cfg.active=true] {Boolean} Indicates whether or not this CameraControl is active.
 @param [cfg.inertia=0.5] {Number} A factor in range [0..1] indicating how much the camera keeps moving after you finish panning or rotating it.
 @extends Component
 */
(function () {

    &quot;use strict&quot;;


    xeogl.CameraControl = xeogl.Component.extend({

        /**
         JavaScript class name for this Component.

         @property type
         @type String
         @final
         */
        type: &quot;xeogl.CameraControl&quot;,

        _init: function (cfg) {

            this._boundaryHelper = new xeogl.Entity(this, {
                geometry: new xeogl.AABBGeometry(this),
                material: new xeogl.PhongMaterial(this, {
                    diffuse: [0, 0, 0],
                    ambient: [0, 0, 0],
                    specular: [0, 0, 0],
                    emissive: [1.0, 1.0, 0.6],
                    lineWidth: 4
                }),
                visible: false,
                collidable: false
            });

            this._cameraFlight = new xeogl.CameraFlightAnimation(this, {
                duration: 0.5
            });

            this.firstPerson = cfg.firstPerson;
            this.walking = cfg.walking;
            this.keyboardLayout = cfg.keyboardLayout;
            this.doublePickFlyTo = cfg.doublePickFlyTo;
            this.active = cfg.active;
            this.inertia = cfg.inertia;

            this._initEvents(); // Set up all the mouse/touch/kb handlers
        },

        _props: {

            /**
             Indicates whether this CameraControl is active or not.

             Fires a {{#crossLink &quot;CameraControl/active:event&quot;}}{{/crossLink}} event on change.

             @property active
             @default true
             @type Boolean
             */
            active: {

                set: function (value) {

                    this._active = value !== false;

                    /**
                     Fired whenever this CameraControl&#x27;s {{#crossLink &quot;CameraControl/active:property&quot;}}{{/crossLink}} property changes.

                     @event active
                     @param value {Boolean} The property&#x27;s new value
                     */
                    this.fire(&quot;active&quot;, this._active);
                },

                get: function () {
                    return this._active;
                }
            },

            /**
             * Flag which indicates whether this CameraControl is in &quot;first person&quot; mode.
             *
             * In &quot;first person&quot; mode (disabled by default) the look position rotates about the eye position. Otherwise,
             * the eye rotates about the look.
             *
             * Fires a {{#crossLink &quot;KeyboardRotateCamera/firstPerson:event&quot;}}{{/crossLink}} event on change.
             *
             * @property firstPerson
             * @default false
             * @type Boolean
             */
            firstPerson: {

                set: function (value) {

                    value = !!value;

                    this._firstPerson = value;

                    /**
                     * Fired whenever this CameraControl&#x27;s {{#crossLink &quot;CameraControl/firstPerson:property&quot;}}{{/crossLink}} property changes.
                     * @event firstPerson
                     * @param value The property&#x27;s new value
                     */
                    this.fire(&#x27;firstPerson&#x27;, this._firstPerson);
                },

                get: function () {
                    return this._firstPerson;
                }
            },

            /**
             * Flag which indicates whether this CameraControl is in &quot;walking&quot; mode.
             *
             * When set true, this constrains eye movement to the horizontal X-Z plane. When doing a walkthrough,
             * this is useful to allow us to look upwards or downwards as we move, while keeping us moving in the
             * horizontal plane.
             *
             * This only has an effect when also in &quot;first person&quot; mode.
             *
             * Fires a {{#crossLink &quot;KeyboardRotateCamera/walking:event&quot;}}{{/crossLink}} event on change.
             *
             * @property walking
             * @default false
             * @type Boolean
             */
            walking: {

                set: function (value) {

                    value = !!value;

                    this._walking = value;

                    /**
                     * Fired whenever this CameraControl&#x27;s {{#crossLink &quot;CameraControl/walking:property&quot;}}{{/crossLink}} property changes.
                     * @event walking
                     * @param value The property&#x27;s new value
                     */
                    this.fire(&#x27;walking&#x27;, this._walking);
                },

                get: function () {
                    return this._walking;
                }
            },

            /**
             * TODO
             * Fires a {{#crossLink &quot;KeyboardRotateCamera/doublePickFlyTo:event&quot;}}{{/crossLink}} event on change.
             *
             * @property doublePickFlyTo
             * @default true
             * @type Boolean
             */
            doublePickFlyTo: {

                set: function (value) {

                    this._doublePickFlyTo = value !== false;

                    // ..

                    /**
                     * Fired whenever this CameraControl&#x27;s {{#crossLink &quot;CameraControl/doublePickFlyTo:property&quot;}}{{/crossLink}} property changes.
                     * @event doublePickFlyTo
                     * @param value The property&#x27;s new value
                     */
                    this.fire(&#x27;doublePickFlyTo&#x27;, this._doublePickFlyTo);
                },

                get: function () {
                    return this._doublePickFlyTo;
                }
            },


            /**
             * A fact in range [0..1] indicating how much the camera keeps moving after you finish
             * panning or rotating it.
             *
             * A value of 0.0 causes it to immediately stop, 0.5 causes its movement to decay 50% on each tick,
             * while 1.0 causes no decay, allowing it continue moving, by the current rate of pan or rotation.
             *
             * You may choose an inertia of zero when you want be able to precisely position or rotate the camera,
             * without interference from inertia. ero inertia can also mean that less frames are rendered while
             * you are positioning the camera.
             *
             * Fires a {{#crossLink &quot;KeyboardRotateCamera/inertia:event&quot;}}{{/crossLink}} event on change.
             *
             * @property inertia
             * @default 0.5
             * @type Number
             */
            inertia: {

                set: function (value) {

                    this._inertia = value === undefined ? 0.5 : value;

                    /**
                     * Fired whenever this CameraControl&#x27;s {{#crossLink &quot;CameraControl/inertia:property&quot;}}{{/crossLink}} property changes.
                     * @event inertia
                     * @param value The property&#x27;s new value
                     */
                    this.fire(&#x27;inertia&#x27;, this._inertia);
                },

                get: function () {
                    return this._inertia;
                }
            },

            /**
             * TODO
             * Fires a {{#crossLink &quot;KeyboardRotateCamera/keyboardLayout:event&quot;}}{{/crossLink}} event on change.
             *
             * @property keyboardLayout
             * @default &quot;qwerty&quot;
             * @type String
             */
            keyboardLayout: {

                set: function (value) {

                    this._keyboardLayout = value || &quot;qwerty&quot;;

                    // ..

                    /**
                     * Fired whenever this CameraControl&#x27;s {{#crossLink &quot;CameraControl/keyboardLayout:property&quot;}}{{/crossLink}} property changes.
                     * @event keyboardLayout
                     * @param value The property&#x27;s new value
                     */
                    this.fire(&#x27;keyboardLayout&#x27;, this._keyboardLayout);
                },

                get: function () {
                    return this._keyboardLayout;
                }
            }
        },

        _destroy: function () {
            this.active = false;
        },

        _initEvents: function () {

            var self = this;
            var scene = this.scene;
            var input = scene.input;
            var camera = scene.camera;
            var math = xeogl.math;
            var canvas = this.scene.canvas.canvas;
            var over = false;
            var mouseHoverDelay = 500;
            var mouseOrbitRate = 0.4;
            var mousePanRate = 0.4;
            var mouseZoomRate = 0.8;
            var mouseWheelPanRate = 0.4;
            var keyboardOrbitRate = .02;
            var keyboardPanRate = .02;
            var keyboardZoomRate = .02;
            var touchRotateRate = 0.3;
            var touchPanRate = 0.2;
            var touchZoomRate = 0.05;

            canvas.oncontextmenu = function (e) {
                e.preventDefault();
            };

            var getClickCoordsWithinElement = (function () {
                var coords = new Float32Array(2);
                return function (event) {
                    if (!event) {
                        event = window.event;
                        coords[0] = event.x;
                        coords[a] = event.y;
                    } else {
                        var element = event.target;
                        var totalOffsetLeft = 0;
                        var totalOffsetTop = 0;

                        while (element.offsetParent) {
                            totalOffsetLeft += element.offsetLeft;
                            totalOffsetTop += element.offsetTop;
                            element = element.offsetParent;
                        }
                        coords[0] = event.pageX - totalOffsetLeft;
                        coords[1] = event.pageY - totalOffsetTop;
                    }
                    return coords;
                };
            })();

            //------------------------------------------------------------------------------------
            // Mouse and touch camera control
            //------------------------------------------------------------------------------------

            (function () {

                var rotateVx = 0;
                var rotateVy = 0;
                var panVx = 0;
                var panVy = 0;
                var panVz = 0;
                var vZoom = 0;

                var ctrlDown = false;
                var altDown = false;
                var shiftDown = false;
                var keyDown = {};

                var EPSILON = 0.001;

                var getEyeLookDist = (function () {
                    var vec = new Float32Array(3);
                    return function () {
                        return math.lenVec3(math.subVec3(camera.look, camera.eye, vec));
                    };
                })();

                scene.on(&quot;tick&quot;, function () {

                    var cameraInertia = self._inertia;

                    if (Math.abs(rotateVx) &lt; EPSILON) {
                        rotateVx = 0;
                    }

                    if (Math.abs(rotateVy) &lt; EPSILON) {
                        rotateVy = 0;
                    }

                    if (rotateVx !== 0) {
                        if (self._firstPerson) {
                            camera.pitch(-rotateVx);
                        } else {
                            camera.orbitPitch(rotateVx);
                        }
                    }

                    if (rotateVy !== 0) {
                        if (self._firstPerson) {
                            camera.yaw(rotateVy);
                        } else {
                            camera.orbitYaw(rotateVy);
                        }
                    }

                    rotateVx *= cameraInertia;
                    rotateVy *= cameraInertia;
                    
                    if (Math.abs(panVx) &lt; EPSILON) {
                        panVx = 0;
                    }

                    if (Math.abs(panVy) &lt; EPSILON) {
                        panVy = 0;
                    }

                    if (Math.abs(panVz) &lt; EPSILON) {
                        panVz = 0;
                    }

                    if (panVx !== 0 || panVy !== 0 || panVz !== 0) {
                        var f = getEyeLookDist() / 80;
                        if (self._walking) {
                            var y = camera.eye[1];
                            camera.pan([panVx * f, panVy * f, panVz * f]);
                            var eye = camera.eye;
                            eye[1] = y;
                            camera.eye = eye;
                        } else {
                            camera.pan([panVx * f, panVy * f, panVz * f]);
                        }
                    }

                    panVx *= cameraInertia;
                    panVy *= cameraInertia;
                    panVz *= cameraInertia;

                    if (Math.abs(vZoom) &lt; EPSILON) {
                        vZoom = 0;
                    }

                    if (vZoom !== 0) {
                        if (self._firstPerson) {
                            var y;
                            if (self._walking) {
                                y = camera.eye[1];
                            }
                            camera.pan([0, 0, vZoom]);
                            if (self._walking) {
                                var eye = camera.eye;
                                eye[1] = y;
                                camera.eye = eye;
                            }
                        } else {
                            // Do both zoom and ortho scale so that we can switch projections without weird scale jumps
                            camera.zoom(vZoom);
                            camera.ortho.scale = camera.ortho.scale + vZoom;
                        }
                        vZoom *= cameraInertia;
                    }
                });

                function getZoomRate() {
                    var aabb = scene.aabb;
                    var xsize = aabb[3] - aabb[0];
                    var ysize = aabb[4] - aabb[1];
                    var zsize = aabb[5] - aabb[2];
                    var max = (xsize &gt; ysize ? xsize : ysize);
                    max = (zsize &gt; max ? zsize : max);
                    return max / 30;
                }

                document.addEventListener(&quot;keyDown&quot;, function (e) {
                    if (!self._active) {
                        return;
                    }
                    if (e.target.tagName !== &quot;INPUT&quot; &amp;&amp; e.target.tagName !== &quot;TEXTAREA&quot;) {
                        ctrlDown = e.ctrlKey || e.keyCode === 17 || e.metaKey; // !important, treat Windows or Mac Command Key as ctrl
                        altDown = e.altKey || e.keyCode === 18;
                        shiftDown = e.keyCode === 16;
                        keyDown[e.keyCode] = true;
                    }
                }, true);

                document.addEventListener(&quot;keyup&quot;, function (e) {
                    if (!self._active) {
                        return;
                    }
                    if (e.target.tagName !== &quot;INPUT&quot; &amp;&amp; e.target.tagName !== &quot;TEXTAREA&quot;) {
                        if (e.ctrlKey || e.keyCode === 17) {
                            ctrlDown = false;
                        }
                        if (e.altKey || e.keyCode === 18) {
                            altDown = false;
                        }
                        if (e.keyCode === 16) {
                            shiftDown = false;
                        }
                        keyDown[e.keyCode] = false;
                    }
                });

                // Mouse camera rotate, pan and zoom

                (function () {

                    var lastX;
                    var lastY;
                    var xDelta = 0;
                    var yDelta = 0;
                    var down = false;

                    var mouseDownLeft;
                    var mouseDownMiddle;
                    var mouseDownRight;

                    canvas.addEventListener(&quot;mousedown&quot;, function (e) {
                        if (!self._active) {
                            return;
                        }
                        if (!over) {
                            return;
                        }
                        switch (e.which) {
                            case 1: // Left button
                                mouseDownLeft = true;
                                down = true;
                                xDelta = 0;
                                yDelta = 0;
                                var coords = getClickCoordsWithinElement(e);
                                lastX = coords[0];
                                lastY = coords[1];
                                break;
                            case 2: // Middle/both buttons
                                mouseDownMiddle = true;
                                break;
                            case 3: // Right button
                                mouseDownRight = true;
                                down = true;
                                xDelta = 0;
                                yDelta = 0;
                                var coords = getClickCoordsWithinElement(e);
                                lastX = coords[0];
                                lastY = coords[1];
                                break;
                                break;
                            default:
                                break;
                        }
                    });

                    canvas.addEventListener(&quot;mouseup&quot;, function (e) {
                        if (!self._active) {
                            return;
                        }
                        switch (e.which) {
                            case 1: // Left button
                                mouseDownLeft = false;
                                break;
                            case 2: // Middle/both buttons
                                mouseDownMiddle = false;
                                break;
                            case 3: // Right button
                                mouseDownRight = false;
                                break;
                            default:
                                break;
                        }
                        down = false;
                        xDelta = 0;
                        yDelta = 0;
                    });

                    canvas.addEventListener(&quot;mouseenter&quot;, function () {
                        if (!self._active) {
                            return;
                        }
                        over = true;
                        xDelta = 0;
                        yDelta = 0;
                    });

                    canvas.addEventListener(&quot;mouseleave&quot;, function () {
                        if (!self._active) {
                            return;
                        }
                        over = false;
                        xDelta = 0;
                        yDelta = 0;
                    });

                    canvas.addEventListener(&quot;mousemove&quot;, function (e) {
                        if (!self._active) {
                            return;
                        }
                        if (!over) {
                            return;
                        }
                        if (!down) {
                            return;
                        }
                        var coords = getClickCoordsWithinElement(e);
                        var x = coords[0];
                        var y = coords[1];
                        xDelta += (x - lastX) * mouseOrbitRate;
                        yDelta += (y - lastY) * mouseOrbitRate;
                        lastX = x;
                        lastY = y;
                    });

                    scene.on(&quot;tick&quot;, function () {
                        if (!self._active) {
                            return;
                        }
                        if (Math.abs(xDelta) === 0 &amp;&amp; Math.abs(yDelta) === 0) {
                            return;
                        }

                        var panning = shiftDown || mouseDownRight;

                        if (panning) {

                            // Panning

                            panVx = xDelta * mousePanRate;
                            panVy = yDelta * mousePanRate;

                        } else {

                            // Orbiting

                            rotateVy = -xDelta * mouseOrbitRate;
                            rotateVx = yDelta * mouseOrbitRate;
                        }

                        xDelta = 0;
                        yDelta = 0;
                    });

                    // Mouse wheel zoom

                    canvas.addEventListener(&quot;wheel&quot;, function (e) {
                        if (!self._active) {
                            return;
                        }
                        var delta = Math.max(-1, Math.min(1, -e.deltaY * 40));
                        if (delta === 0) {
                            return;
                        }
                        var d = delta / Math.abs(delta);
                        if (self._firstPerson) {
                            panVz += -d * mouseWheelPanRate;
                        } else {
                            vZoom = -d * getZoomRate() * mouseZoomRate;
                        }
                        e.preventDefault();
                    });

                    // Keyboard zoom

                    scene.on(&quot;tick&quot;, function (e) {
                        if (!self._active) {
                            return;
                        }
                        if (!over) {
                            return;
                        }
                        var elapsed = e.deltaTime;
                        if (!self.ctrlDown &amp;&amp; !self.altDown) {
                            var wkey = input.keyDown[input.KEY_ADD];
                            var skey = input.keyDown[input.KEY_SUBTRACT];
                            if (wkey || skey) {
                                if (skey) {
                                    vZoom = elapsed * getZoomRate() * keyboardZoomRate;
                                } else if (wkey) {
                                    vZoom = -elapsed * getZoomRate() * keyboardZoomRate;
                                }
                            }
                        }
                    });

                    // Keyboard panning

                    (function () {

                        scene.on(&quot;tick&quot;, function (e) {
                            if (!self._active) {
                                return;
                            }
                            if (!over) {
                                return;
                            }

                            var elapsed = e.deltaTime;

                            // if (!self.ctrlDown &amp;&amp; !self.altDown) {
                            var front, back, left, right, up, down;
                            if (self._keyboardLayout == &#x27;azerty&#x27;) {
                                front = input.keyDown[input.KEY_Z];
                                back = input.keyDown[input.KEY_S];
                                left = input.keyDown[input.KEY_Q];
                                right = input.keyDown[input.KEY_D];
                                up = input.keyDown[input.KEY_W];
                                down = input.keyDown[input.KEY_X];
                            } else {
                                front = input.keyDown[input.KEY_W];
                                back = input.keyDown[input.KEY_S];
                                left = input.keyDown[input.KEY_A];
                                right = input.keyDown[input.KEY_D];
                                up = input.keyDown[input.KEY_Z];
                                down = input.keyDown[input.KEY_X];
                            }
                            if (front || back || left || right || up || down) {
                                if (down) {
                                    panVy += elapsed * keyboardPanRate;
                                } else if (up) {
                                    panVy -= -elapsed * keyboardPanRate;
                                }
                                if (right) {
                                    panVx += -elapsed * keyboardPanRate;
                                } else if (left) {
                                    panVx = elapsed * keyboardPanRate;
                                }
                                if (back) {
                                    panVz = elapsed * keyboardPanRate;
                                } else if (front) {
                                    panVz = -elapsed * keyboardPanRate;
                                }
                            }
                            //          }
                        });
                    })();
                })();

                // Touch camera rotate, pan and zoom

                (function () {

                    var touchStartTime;
                    var tapStartPos = new Float32Array(2);
                    var tapStartTime = -1;

                    var lastTouches = [];
                    var numTouches = 0;

                    var touch0Vec = new Float32Array(2);
                    var touch1Vec = new Float32Array(2);

                    var MODE_CHANGE_TIMEOUT = 50;
                    var MODE_NONE = 0;
                    var MODE_ROTATE = 1;
                    var MODE_PAN = 1 &lt;&lt; 1;
                    var MODE_ZOOM = 1 &lt;&lt; 2;
                    var currentMode = MODE_NONE;
                    var transitionTime = Date.now();

                    function checkMode(mode) {
                        var currentTime = Date.now();
                        if (currentMode === MODE_NONE) {
                            currentMode = mode;
                            return true;
                        }
                        if (currentMode === mode) {
                            return currentTime - transitionTime &gt; MODE_CHANGE_TIMEOUT;
                        }
                        currentMode = mode;
                        transitionTime = currentTime;
                        return false;
                    }

                    canvas.addEventListener(&quot;touchstart&quot;, function (event) {
                        if (!self._active) {
                            return;
                        }
                        var touches = event.touches;
                        var changedTouches = event.changedTouches;

                        touchStartTime = Date.now();

                        if (touches.length === 1 &amp;&amp; changedTouches.length === 1) {
                            tapStartTime = touchStartTime;
                            tapStartPos[0] = touches[0].pageX;
                            tapStartPos[1] = touches[0].pageY;
                        } else {
                            tapStartTime = -1;
                        }

                        while (lastTouches.length &lt; touches.length) {
                            lastTouches.push(new Float32Array(2));
                        }

                        for (var i = 0, len = touches.length; i &lt; len; ++i) {
                            lastTouches[i][0] = touches[i].pageX;
                            lastTouches[i][1] = touches[i].pageY;
                        }

                        currentMode = MODE_NONE;
                        numTouches = touches.length;

                        event.stopPropagation();
                    }, {passive: true});

                    canvas.addEventListener(&quot;touchmove&quot;, function (event) {
                        if (!self._active) {
                            return;
                        }
                        var touches = event.touches;

                        if (numTouches === 1) {

                            var touch0 = touches[0];

                            if (checkMode(MODE_ROTATE)) {
                                var deltaX = touch0.pageX - lastTouches[0][0];
                                var deltaY = touch0.pageY - lastTouches[0][1];
                                var rotateX = deltaX * touchRotateRate;
                                var rotateY = deltaY * touchRotateRate;
                                rotateVx = rotateY;
                                rotateVy = -rotateX;
                            }

                        } else if (numTouches === 2) {

                            var touch0 = touches[0];
                            var touch1 = touches[1];

                            math.subVec2([touch0.pageX, touch0.pageY], lastTouches[0], touch0Vec);
                            math.subVec2([touch1.pageX, touch1.pageY], lastTouches[1], touch1Vec);

                            var panning = math.dotVec2(touch0Vec, touch1Vec) &gt; 0;

                            if (panning &amp;&amp; checkMode(MODE_PAN)) {
                                math.subVec2([touch0.pageX, touch0.pageY], lastTouches[0], touch0Vec);
                                panVx = touch0Vec[0] * touchPanRate;
                                panVy = touch0Vec[1] * touchPanRate;
                            }

                            if (!panning &amp;&amp; checkMode(MODE_ZOOM)) {
                                var d1 = math.distVec2([touch0.pageX, touch0.pageY], [touch1.pageX, touch1.pageY]);
                                var d2 = math.distVec2(lastTouches[0], lastTouches[1]);
                                vZoom = (d2 - d1) * getZoomRate() * touchZoomRate;
                            }
                        }

                        for (var i = 0; i &lt; numTouches; ++i) {
                            lastTouches[i][0] = touches[i].pageX;
                            lastTouches[i][1] = touches[i].pageY;
                        }

                        event.stopPropagation();
                    }, {passive: true});

                })();

                // Keyboard rotation

                (function () {

                    scene.on(&quot;tick&quot;, function (e) {
                        if (!self._active) {
                            return;
                        }
                        if (!over) {
                            return;
                        }
                        var elapsed = e.deltaTime;
                        var left = input.keyDown[input.KEY_LEFT_ARROW];
                        var right = input.keyDown[input.KEY_RIGHT_ARROW];
                        var up = input.keyDown[input.KEY_UP_ARROW];
                        var down = input.keyDown[input.KEY_DOWN_ARROW];
                        if (left || right || up || down) {
                            if (right) {
                                rotateVy += -elapsed * keyboardOrbitRate;

                            } else if (left) {
                                rotateVy += elapsed * keyboardOrbitRate;
                            }
                            if (down) {
                                rotateVx += elapsed * keyboardOrbitRate;

                            } else if (up) {
                                rotateVx += -elapsed * keyboardOrbitRate;
                            }
                        }
                    });
                })();

                // First-person rotation about vertical axis with A and E keys for AZERTY layout

                (function () {

                    scene.on(&quot;tick&quot;, function (e) {
                        if (!self._active) {
                            return;
                        }
                        if (!over) {
                            return;
                        }
                        var elapsed = e.deltaTime;
                        var rotateLeft;
                        var rotateRight;
                        if (self._keyboardLayout == &#x27;azerty&#x27;) {
                            rotateLeft = input.keyDown[input.KEY_A];
                            rotateRight = input.keyDown[input.KEY_E];
                        } else {
                            rotateLeft = input.keyDown[input.KEY_Q];
                            rotateRight = input.keyDown[input.KEY_E];
                        }
                        if (rotateRight || rotateLeft) {
                            if (rotateLeft) {
                                rotateVy += elapsed * keyboardOrbitRate;
                            } else if (rotateRight) {
                                rotateVy += -elapsed * keyboardOrbitRate;
                            }
                        }
                    });

                })();
            })();

            //------------------------------------------------------------------------------------
            // Mouse and touch picking
            //------------------------------------------------------------------------------------

            (function () {

                var cursorPos = [0, 0];
                var needPick = false;
                var needPickSurface = false;
                var lastPickedEntityId;
                var hit;
                var picked = false;
                var pickedSurface = false;

                function update() {
                    if (!needPick &amp;&amp; !needPickSurface) {
                        return;
                    }
                    picked = false;
                    pickedSurface = false;
                    if (needPickSurface || self.hasSubs(&quot;hoverSurface&quot;)) {
                        hit = scene.pick({
                            pickSurface: true,
                            canvasPos: cursorPos
                        });
                    } else { // needPick == true
                        hit = scene.pick({
                            canvasPos: cursorPos
                        });
                    }
                    if (hit) {
                        picked = true;
                        var pickedEntityId = hit.entity.id;
                        if (lastPickedEntityId !== pickedEntityId) {
                            if (lastPickedEntityId !== undefined) {

                                /**
                                 * Fired whenever the pointer no longer hovers over an {{#crossLink &quot;Entity&quot;}}{{/crossLink}}.
                                 * @event hoverOut
                                 * @param entity The Entity
                                 */
                                self.fire(&quot;hoverOut&quot;, {
                                    entity: scene.entities[lastPickedEntityId]
                                });
                            }

                            /**
                             * Fired continuously while the pointer is moving while hovering over an {{#crossLink &quot;Entity&quot;}}{{/crossLink}}.
                             * @event hover
                             * @param hit A pick hit result containing the ID of the Entity - see {{#crossLink &quot;Scene/pick:method&quot;}}{{/crossLink}}.
                             */
                            self.fire(&quot;hover&quot;, hit);
                            lastPickedEntityId = pickedEntityId;
                        }
                        if (hit.worldPos) {
                            pickedSurface = true;

                            /**
                             * Fired while the pointer hovers over the surface of an {{#crossLink &quot;Entity&quot;}}{{/crossLink}}.
                             *
                             * This event provides 3D information about the point on the surface that the pointer is
                             * hovering over.
                             *
                             * @event hoverSurface
                             * @param hit A surface pick hit result, containing the ID of the Entity and 3D info on the
                             * surface possition - see {{#crossLink &quot;Scene/pick:method&quot;}}{{/crossLink}}.
                             */
                            self.fire(&quot;hoverSurface&quot;, hit);
                        }
                    } else {
                        if (lastPickedEntityId !== undefined) {
                            /**
                             * Fired whenever the pointer no longer hovers over an {{#crossLink &quot;Entity&quot;}}{{/crossLink}}.
                             * @event hoverOut
                             * @param entity The Entity
                             */
                            self.fire(&quot;hoverOut&quot;, {
                                entity: scene.entities[lastPickedEntityId]
                            });
                            lastPickedEntityId = undefined;
                        }
                        /**
                         * Fired continuously while the pointer is moving but not hovering over anything.
                         *
                         * @event hoverOff
                         */
                        self.fire(&quot;hoverOff&quot;, {
                            canvasPos: cursorPos
                        });
                    }
                    needPick = false;
                    needPickSurface = false;
                }

                scene.on(&quot;tick&quot;, update);

                function getCoordsWithinElement(event, coords) {
                    if (!event) {
                        event = window.event;
                        coords[0] = event.x;
                        coords[1] = event.y;
                    }
                    else {
                        var element = event.target;
                        var totalOffsetLeft = 0;
                        var totalOffsetTop = 0;

                        while (element.offsetParent) {
                            totalOffsetLeft += element.offsetLeft;
                            totalOffsetTop += element.offsetTop;
                            element = element.offsetParent;
                        }
                        coords[0] = event.pageX - totalOffsetLeft;
                        coords[1] = event.pageY - totalOffsetTop;
                    }
                }

                // Mouse picking

                (function () {

                    canvas.addEventListener(&quot;mousemove&quot;, function (e) {

                        if (!self._active) {
                            return;
                        }

                        //if (down) {
                        //    return;
                        //}

                        getCoordsWithinElement(e, cursorPos);

                        if (self.hasSubs(&quot;hover&quot;) || self.hasSubs(&quot;hoverOut&quot;) || self.hasSubs(&quot;hoverOff&quot;) || self.hasSubs(&quot;hoverSurface&quot;)) {
                            needPick = true;
                        }
                    });

                    var downX;
                    var downY;

                    canvas.addEventListener(&#x27;mousedown&#x27;, function (e) {
                        if (!self._active) {
                            return;
                        }
                        downX = e.clientX;
                        downY = e.clientY;
                    });

                    canvas.addEventListener(&#x27;mouseup&#x27;, (function (e) {
                        var clicks = 0;
                        var timeout;
                        return function (e) {
                            if (!self._active) {
                                return;
                            }
                            if (Math.abs(e.clientX - downX) &gt; 3 || Math.abs(e.clientY - downY) &gt; 3) {
                                return;
                            }

                            if (!self._doublePickFlyTo &amp;&amp; !self.hasSubs(&quot;doublePicked&quot;) &amp;&amp; !self.hasSubs(&quot;doublePickedSurface&quot;) &amp;&amp; !self.hasSubs(&quot;doublePickedNothing&quot;)) {

                                //  Avoid the single/double click differentiation timeout

                                needPickSurface = !!self.hasSubs(&quot;pickedSurface&quot;);

                                update();

                                if (hit) {

                                    /**
                                     * Fired whenever the pointer has picked (ie. clicked or tapped) an {{#crossLink &quot;Entity&quot;}}{{/crossLink}}.
                                     *
                                     * @event picked
                                     * @param hit A surface pick hit result containing the ID of the Entity - see {{#crossLink &quot;Scene/pick:method&quot;}}{{/crossLink}}.
                                     */
                                    self.fire(&quot;picked&quot;, hit);
                                    if (pickedSurface) {

                                        /**
                                         * Fired when the pointer has picked (ie. clicked or tapped) the surface of an {{#crossLink &quot;Entity&quot;}}{{/crossLink}}.
                                         *
                                         * This event provides 3D information about the point on the surface that the pointer has picked.
                                         *
                                         * @event pickedSurface
                                         * @param hit A surface pick hit result, containing the ID of the Entity and 3D info on the
                                         * surface possition - see {{#crossLink &quot;Scene/pick:method&quot;}}{{/crossLink}}.
                                         */
                                        self.fire(&quot;pickedSurface&quot;, hit);
                                    }
                                } else {

                                    /**
                                     * Fired when the pointer attempted a pick (ie. clicked or tapped), but has hit nothing.
                                     *
                                     * @event pickedNothing
                                     */
                                    self.fire(&quot;pickedNothing&quot;);
                                }

                                return;
                            }

                            clicks++;

                            if (clicks == 1) {
                                timeout = setTimeout(function () {

                                    needPick = self._doublePickFlyTo;
                                    needPickSurface = needPick || !!self.hasSubs(&quot;pickedSurface&quot;);

                                    update();

                                    if (hit) {
                                        self.fire(&quot;picked&quot;, hit);
                                        if (pickedSurface) {
                                            self.fire(&quot;pickedSurface&quot;, hit);
                                        }
                                    } else {
                                        self.fire(&quot;pickedNothing&quot;);
                                    }

                                    clicks = 0;
                                }, 250);  // FIXME: Too short for track pads

                            } else {

                                clearTimeout(timeout);

                                needPick = self._doublePickFlyTo;
                                needPickSurface = needPick || !!self.hasSubs(&quot;doublePickedSurface&quot;);

                                update();

                                if (hit) {
                                    /**
                                     * Fired whenever the pointer has double-picked (ie. double-clicked or double-tapped) an {{#crossLink &quot;Entity&quot;}}{{/crossLink}}.
                                     *
                                     * @event picked
                                     * @param hit A surface pick hit result containing the ID of the Entity - see {{#crossLink &quot;Scene/pick:method&quot;}}{{/crossLink}}.
                                     */
                                    self.fire(&quot;doublePicked&quot;, hit);
                                    if (pickedSurface) {
                                        /**
                                         * Fired when the pointer has double-picked (ie. double-clicked or double-tapped) the surface of an {{#crossLink &quot;Entity&quot;}}{{/crossLink}}.
                                         *
                                         * This event provides 3D information about the point on the surface that the pointer has picked.
                                         *
                                         * @event doublePickedSurface
                                         * @param hit A surface pick hit result, containing the ID of the Entity and 3D info on the
                                         * surface possition - see {{#crossLink &quot;Scene/pick:method&quot;}}{{/crossLink}}.
                                         */
                                        self.fire(&quot;doublePickedSurface&quot;, hit);
                                    }
                                    if (self._doublePickFlyTo) {
                                        self._flyTo(hit);
                                    }
                                } else {

                                    /**
                                     * Fired when the pointer attempted a double-pick (ie. double-clicked or double-tapped), but has hit nothing.
                                     *
                                     * @event doublePickedNothing
                                     */
                                    self.fire(&quot;doublePickedNothing&quot;);
                                    if (self._doublePickFlyTo) {
                                        self._flyTo();
                                    }
                                }
                                clicks = 0;
                            }
                        };
                    })(), false);

                })();

                // Touch picking

                (function () {

                    var TAP_INTERVAL = 150;
                    var DBL_TAP_INTERVAL = 325;
                    var TAP_DISTANCE_THRESHOLD = 4;

                    var touchStartTime;
                    var activeTouches = [];
                    var tapStartPos = new Float32Array(2);
                    var tapStartTime = -1;
                    var lastTapTime = -1;

                    canvas.addEventListener(&quot;touchstart&quot;, function (event) {

                        if (!self._active) {
                            return;
                        }

                        var touches = event.touches;
                        var changedTouches = event.changedTouches;

                        touchStartTime = Date.now();

                        if (touches.length === 1 &amp;&amp; changedTouches.length === 1) {
                            tapStartTime = touchStartTime;
                            tapStartPos[0] = touches[0].pageX;
                            tapStartPos[1] = touches[0].pageY;
                        } else {
                            tapStartTime = -1;
                        }

                        while (activeTouches.length &lt; touches.length) {
                            activeTouches.push(new Float32Array(2))
                        }

                        for (var i = 0, len = touches.length; i &lt; len; ++i) {
                            activeTouches[i][0] = touches[i].pageX;
                            activeTouches[i][1] = touches[i].pageY;
                        }

                        activeTouches.length = touches.length;

                        event.stopPropagation();
                    }, {passive: true});

                    //canvas.addEventListener(&quot;touchmove&quot;, function (event) {
                    //    event.preventDefault();
                    //    event.stopPropagation();
                    //});

                    canvas.addEventListener(&quot;touchend&quot;, function (event) {

                        if (!self._active) {
                            return;
                        }

                        var currentTime = Date.now();
                        var touches = event.touches;
                        var changedTouches = event.changedTouches;

                        // process tap

                        if (touches.length === 0 &amp;&amp; changedTouches.length === 1) {

                            if (tapStartTime &gt; -1 &amp;&amp; currentTime - tapStartTime &lt; TAP_INTERVAL) {

                                if (lastTapTime &gt; -1 &amp;&amp; tapStartTime - lastTapTime &lt; DBL_TAP_INTERVAL) {

                                    // Double-tap

                                    cursorPos[0] = Math.round(changedTouches[0].clientX);
                                    cursorPos[1] = Math.round(changedTouches[0].clientY);
                                    needPick = true;
                                    needPickSurface = !!self.hasSubs(&quot;pickedSurface&quot;);

                                    update();

                                    if (hit) {
                                        self.fire(&quot;doublePicked&quot;, hit);
                                        if (pickedSurface) {
                                            self.fire(&quot;doublePickedSurface&quot;, hit);
                                        }
                                        if (self._doublePickFlyTo) {
                                            self._flyTo(hit);
                                        }
                                    } else {
                                        self.fire(&quot;doublePickedNothing&quot;);
                                        if (self._doublePickFlyTo) {
                                            self._flyTo();
                                        }
                                    }

                                    lastTapTime = -1;

                                } else if (xeogl.math.distVec2(activeTouches[0], tapStartPos) &lt; TAP_DISTANCE_THRESHOLD) {

                                    // Single-tap

                                    cursorPos[0] = Math.round(changedTouches[0].clientX);
                                    cursorPos[1] = Math.round(changedTouches[0].clientY);
                                    needPick = true;
                                    needPickSurface = !!self.hasSubs(&quot;pickedSurface&quot;);

                                    update();

                                    if (hit) {
                                        self.fire(&quot;picked&quot;, hit);
                                        if (pickedSurface) {
                                            self.fire(&quot;pickedSurface&quot;, hit);
                                        }
                                    } else {
                                        self.fire(&quot;pickedNothing&quot;);
                                    }

                                    lastTapTime = currentTime;
                                }

                                tapStartTime = -1
                            }
                        }

                        activeTouches.length = touches.length;

                        for (var i = 0, len = touches.length; i &lt; len; ++i) {
                            activeTouches[i][0] = touches[i].pageX;
                            activeTouches[i][1] = touches[i].pageY;
                        }

                        event.stopPropagation();
                    }, {passive: true});
                })();
            })();

            //------------------------------------------------------------------------------------
            // Keyboard camera control
            //------------------------------------------------------------------------------------

            (function () {

                var KEY_NUM_1 = 49;
                var KEY_NUM_2 = 50;
                var KEY_NUM_3 = 51;
                var KEY_NUM_4 = 52;
                var KEY_NUM_5 = 53;
                var KEY_NUM_6 = 54;

                var center = new math.vec3();
                var tempVec3a = new math.vec3();
                var tempVec3b = new math.vec3();
                var tempVec3c = new math.vec3();

                var cameraTarget = {
                    eye: new Float32Array(3),
                    look: new Float32Array(3),
                    up: new Float32Array(3)
                };

                document.addEventListener(&quot;keydown&quot;, function (e) {

                    if (!self._active) {
                        return;
                    }

                    if (!over) {
                        return;
                    }

                    var keyCode = e.keyCode;

                    if (keyCode !== KEY_NUM_1 &amp;&amp;
                        keyCode !== KEY_NUM_2 &amp;&amp;
                        keyCode !== KEY_NUM_3 &amp;&amp;
                        keyCode !== KEY_NUM_4 &amp;&amp;
                        keyCode !== KEY_NUM_5 &amp;&amp;
                        keyCode !== KEY_NUM_6) {
                        return;
                    }

                    var aabb = scene.aabb;
                    var diag = math.getAABB3Diag(aabb);
                    center[0] = aabb[0] + aabb[3] / 2.0;
                    center[1] = aabb[1] + aabb[4] / 2.0;
                    center[2] = aabb[2] + aabb[5] / 2.0;
                    var dist = Math.abs((diag) / Math.tan(self._cameraFlight.fitFOV / 2));

                    switch (keyCode) {

                        case KEY_NUM_1: // Right

                            cameraTarget.eye.set(math.mulVec3Scalar(camera.worldRight, dist, tempVec3a));
                            cameraTarget.look.set(center);
                            cameraTarget.up.set(camera.worldUp);

                            break;

                        case KEY_NUM_2: // Back

                            cameraTarget.eye.set(math.mulVec3Scalar(camera.worldForward, dist, tempVec3a));
                            cameraTarget.look.set(center);
                            cameraTarget.up.set(camera.worldUp);

                            break;

                        case KEY_NUM_3: // Left

                            cameraTarget.eye.set(math.mulVec3Scalar(camera.worldRight, -dist, tempVec3a));
                            cameraTarget.look.set(center);
                            cameraTarget.up.set(camera.worldUp);

                            break;

                        case KEY_NUM_4: // Front

                            cameraTarget.eye.set(math.mulVec3Scalar(camera.worldForward, -dist, tempVec3a));
                            cameraTarget.look.set(center);
                            cameraTarget.up.set(camera.worldUp);

                            break;

                        case KEY_NUM_5: // Top

                            cameraTarget.eye.set(math.mulVec3Scalar(camera.worldUp, dist, tempVec3a));
                            cameraTarget.look.set(center);
                            cameraTarget.up.set(math.normalizeVec3(math.mulVec3Scalar(camera.worldForward, 1, tempVec3b), tempVec3c));

                            break;

                        case KEY_NUM_6: // Bottom

                            cameraTarget.eye.set(math.mulVec3Scalar(camera.worldUp, -dist, tempVec3a));
                            cameraTarget.look.set(center);
                            cameraTarget.up.set(math.normalizeVec3(math.mulVec3Scalar(camera.worldForward, -1, tempVec3b)));

                            break;

                        default:
                            return;
                    }

                    if (self._cameraFlight.duration &gt; 0) {
                        self._cameraFlight.flyTo(cameraTarget);
                    } else {
                        self._cameraFlight.jumpTo(cameraTarget);
                    }
                });

            })();
        },

        _flyTo: function (hit) {

            var pos;

            if (hit &amp;&amp; hit.worldPos) {
                pos = hit.worldPos
            }

            var aabb = hit ? hit.entity.aabb : this.scene.aabb;

            this._boundaryHelper.geometry.targetAABB = aabb;
            //    this._boundaryHelper.visible = true;

            if (pos) {

                // Fly to look at point, don&#x27;t change eye-&gt;look dist

                var camera = this.scene.camera;
                var diff = xeogl.math.subVec3(camera.eye, camera.look, []);

                this._cameraFlight.flyTo({
                        // look: pos,
                        // eye: xeogl.math.addVec3(pos, diff, []),
                        // up: camera.up,
                        aabb: aabb
                    },
                    this._hideBoundary, this);

                // TODO: Option to back off to fit AABB in view

            } else {

                // Fly to fit target boundary in view

                this._cameraFlight.flyTo({
                        aabb: aabb
                    },
                    this._hideBoundary, this);
            }
        },

        _hideBoundary: function () {
            //    this._boundaryHelper.visible = false;
        }
    });

})();

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
